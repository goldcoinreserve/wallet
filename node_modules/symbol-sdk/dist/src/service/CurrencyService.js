"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyService = void 0;
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/internal/operators");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const mosaic_1 = require("../model/mosaic");
const namespace_1 = require("../model/namespace");
/**
 * A service used to load Currencies objects.
 */
class CurrencyService {
    constructor(repositoryFactory) {
        this.repositoryFactory = repositoryFactory;
    }
    /**
     * This method loads the network currencies.
     */
    getNetworkCurrencies() {
        return this.repositoryFactory
            .createNetworkRepository()
            .getNetworkProperties()
            .pipe(operators_1.flatMap((properties) => {
            if (!properties.chain.currencyMosaicId) {
                throw new Error('currencyMosaicId could not be loaded from network properties!!');
            }
            if (!properties.chain.harvestingMosaicId) {
                throw new Error('harvestingMosaicId could not be loaded from network properties!!');
            }
            const currencyMosaic = new mosaic_1.MosaicId(DtoMapping_1.DtoMapping.toSimpleHex(properties.chain.currencyMosaicId));
            const harvestingMosaic = new mosaic_1.MosaicId(DtoMapping_1.DtoMapping.toSimpleHex(properties.chain.harvestingMosaicId));
            const mosaicIds = currencyMosaic.equals(harvestingMosaic) ? [currencyMosaic] : [currencyMosaic, harvestingMosaic];
            return this.getCurrencies(mosaicIds).pipe(operators_1.map((networkCurrencies) => {
                const currency = networkCurrencies.filter((c) => currencyMosaic.equals(c.mosaicId))[0];
                const harvest = networkCurrencies.filter((c) => harvestingMosaic.equals(c.mosaicId))[0];
                return new mosaic_1.NetworkCurrencies(currency, harvest);
            }));
        }));
    }
    getCurrencies(mosaicIds) {
        const mosaicHttp = this.repositoryFactory.createMosaicRepository();
        const namespaceHttp = this.repositoryFactory.createNamespaceRepository();
        // get mosaicInfo and mosaic names from the network,
        // build network currency models
        return rxjs_1.forkJoin({
            mosaicsInfo: mosaicHttp.getMosaics(mosaicIds).toPromise(),
            mosaicNames: namespaceHttp.getMosaicsNames(mosaicIds).toPromise(),
        }).pipe(operators_1.map(({ mosaicsInfo, mosaicNames }) => mosaicsInfo.map((mosaicInfo) => {
            const thisMosaicNames = mosaicNames.find((mn) => mn.mosaicId.equals(mosaicInfo.id)) || new mosaic_1.MosaicNames(mosaicInfo.id, []);
            return this.getCurrency(mosaicInfo, thisMosaicNames);
        })));
    }
    /**
     * Creates a network currency model given mosaic info and mosaic names
     * @param {MosaicInfo} mosaicInfo
     * @param {MosaicNames} mosaicName
     * @returns {(Currency | undefined)}
     */
    getCurrency(mosaicInfo, mosaicName) {
        const mosaicId = mosaicInfo.id;
        const namespaceName = this.getName([mosaicName], mosaicId);
        const namespaceId = namespaceName ? new namespace_1.NamespaceId(namespaceName) : undefined;
        return new mosaic_1.Currency({
            mosaicId: mosaicId,
            namespaceId: namespaceId,
            divisibility: mosaicInfo.divisibility,
            transferable: mosaicInfo.flags.transferable,
            supplyMutable: mosaicInfo.flags.supplyMutable,
            restrictable: mosaicInfo.flags.restrictable,
        });
    }
    getName(mosaicNames, accountMosaicDto) {
        var _a;
        return (_a = mosaicNames
            .filter((n) => n.mosaicId.equals(accountMosaicDto))
            .filter((n) => n.names.length)
            .map((n) => n.names[0].name)) === null || _a === void 0 ? void 0 : _a[0];
    }
}
exports.CurrencyService = CurrencyService;
//# sourceMappingURL=CurrencyService.js.map