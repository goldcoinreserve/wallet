"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTransactionFromPayload = void 0;
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const transaction_1 = require("../../model/transaction");
/**
 * @internal
 * @param payload - The transaction binary data
 * @param isEmbedded - Is the transaction an embedded inner transaction
 * @returns {Transaction | InnerTransaction}
 * @constructor
 */
exports.CreateTransactionFromPayload = (payload, isEmbedded = false) => {
    const transactionBuilder = isEmbedded
        ? catbuffer_typescript_1.EmbeddedTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
        : catbuffer_typescript_1.TransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
    const type = transactionBuilder.getType().valueOf();
    const version = transactionBuilder.getVersion();
    if (type === transaction_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION) {
        return transaction_1.AccountAddressRestrictionTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION) {
        return transaction_1.AccountMosaicRestrictionTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION) {
        return transaction_1.AccountOperationRestrictionTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.ACCOUNT_KEY_LINK) {
        return transaction_1.AccountKeyLinkTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.ADDRESS_ALIAS) {
        return transaction_1.AddressAliasTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.MOSAIC_ALIAS) {
        return transaction_1.MosaicAliasTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.MOSAIC_DEFINITION) {
        return transaction_1.MosaicDefinitionTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.MOSAIC_SUPPLY_CHANGE) {
        return transaction_1.MosaicSupplyChangeTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.NAMESPACE_REGISTRATION) {
        return transaction_1.NamespaceRegistrationTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.TRANSFER) {
        return transaction_1.TransferTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.SECRET_LOCK) {
        return transaction_1.SecretLockTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.SECRET_PROOF) {
        return transaction_1.SecretProofTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION) {
        return transaction_1.MultisigAccountModificationTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.HASH_LOCK) {
        return transaction_1.LockFundsTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION) {
        return transaction_1.MosaicGlobalRestrictionTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION) {
        return transaction_1.MosaicAddressRestrictionTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.ACCOUNT_METADATA) {
        return transaction_1.AccountMetadataTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.MOSAIC_METADATA) {
        return transaction_1.MosaicMetadataTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.NAMESPACE_METADATA) {
        return transaction_1.NamespaceMetadataTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.VRF_KEY_LINK) {
        return transaction_1.VrfKeyLinkTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.NODE_KEY_LINK) {
        return transaction_1.NodeKeyLinkTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.VOTING_KEY_LINK && version == transaction_1.TransactionVersion.VOTING_KEY_LINK) {
        return transaction_1.VotingKeyLinkTransaction.createFromPayload(payload, isEmbedded);
    }
    else if (type === transaction_1.TransactionType.AGGREGATE_COMPLETE || type === transaction_1.TransactionType.AGGREGATE_BONDED) {
        return transaction_1.AggregateTransaction.createFromPayload(payload);
    }
    else {
        throw new Error(`Transaction type ${type} not implemented yet for version ${version}.`);
    }
};
//# sourceMappingURL=CreateTransactionFromPayload.js.map